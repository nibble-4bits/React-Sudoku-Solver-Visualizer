{"version":3,"sources":["util/util.ts","util/sudoku.ts","components/SudokuCell.tsx","components/SudokuBoard.tsx","components/SudokuSolver.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["clamp","value","min","max","deepCopy","copiedObject","Array","isArray","objectValue","key","Object","prototype","hasOwnProperty","call","element","sleep","ms","a","Promise","resolve","setTimeout","random","Error","Math","floor","shuffle","arr","arrCopy","i","length","j","temp","generateEmptySudokuBoard","from","isGiven","isCellInBox","referenceRow","referenceCol","testRow","testCol","rowStart","rowEnd","colStart","colEnd","y","x","isValidValue","testValue","row","col","sudoku","isValidRowValue","isValidColValue","isValidBoxValue","findNextEmptyCell","solveSudoku","fillCellsSequentially","steps","push","emptyCell","possibleNums","possibleNum","Input","styled","input","props","highlight","SudokuCell","ref","onChange","onFocus","isHighlighted","disabled","onKeyDown","type","e","target","includes","preventDefault","test","onBlur","forwardRef","Wrapper","div","SudokuBoard","board","setBoardCell","disableUserInput","useState","focusedCell","setFocusedCell","focusedRow","focusedCol","cellRefs","useRef","createRef","handleKeyDown","aboveRow","belowRow","prevCol","nextCol","current","focus","map","boardRow","cell","inputVal","parseInt","handleChange","UnsolvableNotice","p","SolvingSpeedWrapper","SolvingSpeedLabel","label","SolvingSpeedInput","ButtonWrapper","Button","button","SudokuSolver","sudokuBoard","setSudokuBoard","solvingSteps","setSolvingSteps","isUnsolvable","setIsUnsolvable","solvingSpeed","setSolvingSpeed","isSolvingSudoku","setIsSolvingSudoku","currentStepIdx","useEffect","numericSolvingSpeed","skipPreviousEffect","step","showSteps","valuesCopy","htmlFor","id","onClick","solveSudokuSteps","initialSudoku","cellPositions","emptyCells","shuffledCellPositions","slice","generateSolvableSudokuBoard","AppWrapper","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.09aba299.chunk.js","sourcesContent":["import { Indexable } from '../typings/Indexable';\n\n/**\n * Clamps a value between an upper and lower bound\n * @param value The value to be clamped, if necessary\n * @param min The minimum allowed value\n * @param max The maximum allowed value\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (value < min) return min;\n\n  if (value > max) return max;\n\n  return value;\n}\n\n/**\n * Returns the deep copy of any object\n * @param value The object to be deep copied\n */\nexport function deepCopy(value: unknown): unknown {\n  if (typeof value !== 'object' || value === null) {\n    return value;\n  }\n\n  const copiedObject: Indexable = Array.isArray(value) ? [] : {};\n  const objectValue = value as Indexable;\n\n  for (const key in objectValue) {\n    if (Object.prototype.hasOwnProperty.call(objectValue, key)) {\n      const element = objectValue[key];\n\n      copiedObject[key] = deepCopy(element);\n    }\n  }\n\n  return copiedObject;\n}\n\n/**\n * Pauses execution for a certain number of milliseconds\n * @param ms Number of milliseconds to pause\n */\nexport async function sleep(ms: number): Promise<void> {\n  if (ms === 0) return;\n\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\n/**\n * Returns a random integer between a `min` and `max` value (inclusive)\n * @param min The minimum value in the range\n * @param max The maximum value in the range\n */\nexport function random(min: number, max: number): number {\n  if (min > max) {\n    throw new Error('min param MUST be less or equal to max');\n  }\n\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Shuffles an array using the Fisher-Yates algorithm\n * @param arr The array to be shuffled\n */\nexport function shuffle<T>(arr: T[]): T[] {\n  const arrCopy = deepCopy(arr) as T[];\n\n  for (let i = arrCopy.length - 1; i > 0; i--) {\n    const j = random(0, i);\n\n    const temp = arrCopy[i];\n    arrCopy[i] = arrCopy[j];\n    arrCopy[j] = temp;\n  }\n\n  return arrCopy;\n}\n","import { createRef } from 'react';\nimport { Board } from '../typings/Board';\nimport { deepCopy, random, shuffle } from './util';\n\nexport function generateEmptySudokuBoard(): Board {\n  return Array.from({ length: 9 }, () =>\n    Array.from({ length: 9 }, () => ({ value: 0, isGiven: false }))\n  );\n}\n\nexport function generateSolvableSudokuBoard(): Board {\n  const initialSudoku = generateEmptySudokuBoard();\n  const cellPositions = [];\n\n  solveSudoku(initialSudoku, false);\n\n  for (let i = 0; i < initialSudoku.length; i++) {\n    for (let j = 0; j < initialSudoku[i].length; j++) {\n      cellPositions.push([i, j]);\n    }\n  }\n\n  // Randomly remove between 48 and 62 cells from the generated sudoku\n  const emptyCells = random(48, 62);\n  const shuffledCellPositions = shuffle(cellPositions).slice(0, emptyCells);\n\n  for (let i = 0; i < shuffledCellPositions.length; i++) {\n    const [row, col] = shuffledCellPositions[i];\n    initialSudoku[row][col].value = 0;\n  }\n\n  for (let i = 0; i < initialSudoku.length; i++) {\n    for (let j = 0; j < initialSudoku[i].length; j++) {\n      initialSudoku[i][j].isGiven = initialSudoku[i][j].value > 0;\n    }\n  }\n\n  return initialSudoku;\n}\n\nexport function generateSudokuCellRefs<T>(): React.RefObject<T>[][] {\n  return Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => createRef()));\n}\n\n/**\n * Checks whether a cell (given its row) is part of a certain row in the sudoku board\n * @param referenceRow The row to test against\n * @param testRow The row of the cell to test if it belongs to the `referenceRow`\n * @returns boolean\n */\nexport function isCellInRow(referenceRow: number, testRow: number): boolean {\n  if (referenceRow < 0) return false;\n\n  return referenceRow === testRow;\n}\n\n/**\n * Checks whether a cell (given its column) is part of a certain column in the sudoku board\n * @param referenceCol The column to test against\n * @param testCol The column of the cell to test if it belongs to the `referenceRow`\n * @returns boolean\n */\nexport function isCellInCol(referenceCol: number, testCol: number): boolean {\n  if (referenceCol < 0) return false;\n\n  return referenceCol === testCol;\n}\n\n/**\n * Checks whether a cell (given its row and column) is part of a certain box in the sudoku board\n * @param referenceRow The row to test against\n * @param referenceCol The column to test against\n * @param testRow The row of the cell to test if it belongs to the `referenceRow`\n * @param testCol The column of the cell to test if it belongs to the `referenceCol`\n * @returns boolean\n */\nexport function isCellInBox(\n  referenceRow: number,\n  referenceCol: number,\n  testRow: number,\n  testCol: number\n): boolean {\n  if (referenceRow < 0 || referenceCol < 0) return false;\n\n  const rowStart = referenceRow - (referenceRow % 3);\n  const rowEnd = rowStart + 3;\n  const colStart = referenceCol - (referenceCol % 3);\n  const colEnd = colStart + 3;\n\n  for (let y = rowStart; y < rowEnd; y++) {\n    for (let x = colStart; x < colEnd; x++) {\n      if (y === testRow && x === testCol) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function isValidValue(testValue: number, row: number, col: number, sudoku: Board): boolean {\n  return (\n    isValidRowValue(testValue, row, sudoku) &&\n    isValidColValue(testValue, col, sudoku) &&\n    isValidBoxValue(testValue, row, col, sudoku)\n  );\n}\n\nexport function isValidRowValue(testValue: number, row: number, sudoku: Board): boolean {\n  for (let x = 0; x < sudoku[row].length; x++) {\n    const currCell = sudoku[row][x];\n    if (testValue === currCell.value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isValidColValue(testValue: number, col: number, sudoku: Board): boolean {\n  for (let y = 0; y < sudoku.length; y++) {\n    const currCell = sudoku[y][col];\n    if (testValue === currCell.value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isValidBoxValue(\n  testValue: number,\n  row: number,\n  col: number,\n  sudoku: Board\n): boolean {\n  const rowStart = row - (row % 3);\n  const rowEnd = rowStart + 3;\n  const colStart = col - (col % 3);\n  const colEnd = colStart + 3;\n\n  for (let y = rowStart; y < rowEnd; y++) {\n    for (let x = colStart; x < colEnd; x++) {\n      const currCell = sudoku[y][x];\n      if (testValue === currCell.value) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function findNextEmptyCell(sudoku: Board): [number, number] | null {\n  for (let i = 0; i < sudoku.length; i++) {\n    for (let j = 0; j < sudoku[i].length; j++) {\n      if (!sudoku[i][j].value) {\n        return [i, j];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function solveSudoku(sudoku: Board, fillCellsSequentially = true, steps?: Board[]): boolean {\n  if (steps) steps.push(deepCopy(sudoku) as Board);\n\n  const emptyCell = findNextEmptyCell(sudoku);\n  if (!emptyCell) {\n    return true;\n  }\n\n  const [row, col] = emptyCell;\n  let possibleNums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n  if (!fillCellsSequentially) {\n    possibleNums = shuffle(possibleNums);\n  }\n\n  for (const possibleNum of possibleNums) {\n    if (isValidValue(possibleNum, row, col, sudoku)) {\n      sudoku[row][col].value = possibleNum;\n\n      if (solveSudoku(sudoku, fillCellsSequentially, steps)) {\n        return true;\n      }\n\n      sudoku[row][col].value = 0;\n    }\n  }\n\n  return false;\n}\n\nexport function solveSudokuSteps(sudoku: Board): Board[] | null {\n  const steps: Board[] = [];\n\n  const solved = solveSudoku(sudoku, true, steps);\n\n  if (solved) return steps;\n  return null;\n}\n","import React, { forwardRef } from 'react';\nimport styled from 'styled-components';\n\ninterface InputProps {\n  isGiven: boolean;\n  row: number;\n  col: number;\n  highlight: boolean;\n}\n\nconst Input = styled.input<InputProps>`\n  width: 100%;\n  height: 100%;\n  border: 1px solid #000;\n  border-left: ${(props) => props.col > 0 && props.col % 3 === 0 && '3px solid #000'};\n  border-top: ${(props) => props.row > 0 && props.row % 3 === 0 && '3px solid #000'};\n  color: ${(props) => (props.isGiven ? '#000' : '#f00')};\n  background-color: ${(props) => props.highlight && '#ddd'};\n  caret-color: #000;\n  outline: none;\n  font-size: 4rem;\n  text-align: center;\n  padding: 0;\n\n  &:disabled {\n    background-color: #fff;\n  }\n\n  // Hide increment/decrement arrows\n  -moz-appearance: textfield;\n  &::-webkit-outer-spin-button,\n  &::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n`;\n\ninterface SudokuCellProps {\n  row: number;\n  col: number;\n  value: number;\n  isGiven: boolean;\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n  onFocus: React.Dispatch<React.SetStateAction<number[]>>;\n  isHighlighted: boolean;\n  disabled?: boolean;\n  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n}\n\nfunction SudokuCell(props: SudokuCellProps, ref: React.ForwardedRef<HTMLInputElement>) {\n  const { row, col, value, isGiven, onChange, onFocus, isHighlighted, disabled, onKeyDown } = props;\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    // First, call props onKeyDown event handler, if defined\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n\n    const {\n      key,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      target: { value },\n    } = e;\n\n    // Prevent up and down arrow keys from incrementing/decrementing focused cell value\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      e.preventDefault();\n    }\n\n    // Prevent entering more than 1 digit, if cell already has a value and the pressed key is a number key\n    if (value && /\\d/.test(key)) {\n      e.preventDefault();\n    }\n  };\n\n  const handleFocus = () => {\n    onFocus([row, col]);\n  };\n\n  const handleBlur = () => {\n    onFocus([-1, -1]);\n  };\n\n  return (\n    <Input\n      ref={ref}\n      type=\"number\"\n      min=\"1\"\n      max=\"9\"\n      onKeyDown={handleKeyDown}\n      onChange={onChange}\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      value={value || ''}\n      isGiven={isGiven}\n      row={row}\n      col={col}\n      disabled={disabled}\n      highlight={isHighlighted}\n    />\n  );\n}\n\nexport default forwardRef(SudokuCell);\n","import React, { useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { Board } from '../typings/Board';\nimport {\n  generateSudokuCellRefs,\n  isCellInBox,\n  isCellInCol,\n  isCellInRow,\n  isValidValue,\n} from '../util/sudoku';\nimport { clamp } from '../util/util';\nimport SudokuCell from './SudokuCell';\n\nconst Wrapper = styled.div`\n  width: 600px;\n  height: 600px;\n  display: grid;\n  grid-template-rows: repeat(9, 1fr);\n  grid-template-columns: repeat(9, 1fr);\n  border: 5px solid #000;\n  overflow: hidden;\n`;\n\ninterface SudokuBoardProps {\n  board: Board;\n  setBoardCell: (value: number, row: number, col: number) => void;\n  disableUserInput?: boolean;\n}\n\nfunction SudokuBoard(props: SudokuBoardProps): JSX.Element {\n  const { board, setBoardCell, disableUserInput } = props;\n\n  // This state variable holds a pair of [row, col] coordinates that represent the current focused cell\n  const [focusedCell, setFocusedCell] = useState([-1, -1]);\n  const [focusedRow, focusedCol] = focusedCell;\n\n  // An array of array of refs. Each ref holds a reference to the actual input element that represents a cell\n  // This is used to focus the current focused cell when using the arrow keys in the `handleKeyDown` event handler\n  const cellRefs = useRef<React.RefObject<HTMLInputElement>[][]>(generateSudokuCellRefs());\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>, row: number, col: number) => {\n    const inputVal = parseInt(e.target.value);\n\n    if (isValidValue(inputVal, row, col, board)) {\n      setBoardCell(inputVal, row, col);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const { key } = e;\n    const aboveRow = clamp(focusedRow - 1, 0, board.length - 1);\n    const belowRow = clamp(focusedRow + 1, 0, board.length - 1);\n    const prevCol = clamp(focusedCol - 1, 0, board.length - 1);\n    const nextCol = clamp(focusedCol + 1, 0, board.length - 1);\n\n    switch (key) {\n      case 'ArrowUp':\n        cellRefs.current[aboveRow][focusedCol].current?.focus();\n        break;\n      case 'ArrowDown':\n        cellRefs.current[belowRow][focusedCol].current?.focus();\n        break;\n      case 'ArrowLeft':\n        cellRefs.current[focusedRow][prevCol].current?.focus();\n        break;\n      case 'ArrowRight':\n        cellRefs.current[focusedRow][nextCol].current?.focus();\n        break;\n      default:\n        break;\n    }\n  };\n\n  return (\n    <Wrapper>\n      {board.map((boardRow, i) => {\n        return boardRow.map((cell, j) => {\n          return (\n            <SudokuCell\n              ref={cellRefs.current[i][j]}\n              key={i + j}\n              row={i}\n              col={j}\n              value={cell.value}\n              isGiven={cell.isGiven}\n              onChange={(e) => {\n                handleChange(e, i, j);\n              }}\n              onFocus={setFocusedCell}\n              isHighlighted={\n                isCellInRow(focusedRow, i) ||\n                isCellInCol(focusedCol, j) ||\n                isCellInBox(focusedRow, focusedCol, i, j)\n              }\n              disabled={disableUserInput}\n              onKeyDown={handleKeyDown}\n            />\n          );\n        });\n      })}\n    </Wrapper>\n  );\n}\n\nexport default SudokuBoard;\n","import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { Board } from '../typings/Board';\nimport {\n  generateEmptySudokuBoard,\n  generateSolvableSudokuBoard,\n  solveSudokuSteps,\n} from '../util/sudoku';\nimport { deepCopy, sleep } from '../util/util';\nimport SudokuBoard from './SudokuBoard';\n\nconst Wrapper = styled.div`\n  display: grid;\n  grid-template-rows: auto 10fr 4rem 4rem;\n  gap: 2rem;\n`;\n\nconst UnsolvableNotice = styled.p`\n  margin: 0;\n  font-size: 3rem;\n  text-align: center;\n  color: #f00;\n`;\n\nconst SolvingSpeedWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  gap: 1rem;\n`;\n\nconst SolvingSpeedLabel = styled.label`\n  font-size: 2rem;\n`;\n\nconst SolvingSpeedInput = styled.input`\n  width: 10rem;\n  height: 75%;\n  text-align: center;\n  font-size: 2rem;\n`;\n\nconst ButtonWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  gap: 5rem;\n`;\n\nconst Button = styled.button`\n  color: #fff;\n  background-color: #267ef1;\n  font-size: 1.8rem;\n  width: 20%;\n  border: none;\n  border-radius: 5px;\n\n  &:hover {\n    background-color: #256cca;\n    cursor: pointer;\n  }\n\n  &:disabled {\n    background-color: #478fec;\n    cursor: not-allowed;\n  }\n`;\n\nfunction SudokuSolver(): JSX.Element {\n  // This state variable holds a representation of the sudoku board as an array of 9x9 cells\n  const [sudokuBoard, setSudokuBoard] = useState(generateEmptySudokuBoard());\n  const [solvingSteps, setSolvingSteps] = useState<Board[]>([]);\n  const [isUnsolvable, setIsUnsolvable] = useState(false);\n\n  const [solvingSpeed, setSolvingSpeed] = useState('1');\n  const [isSolvingSudoku, setIsSolvingSudoku] = useState(false);\n  const currentStepIdx = useRef(0);\n\n  useEffect(() => {\n    const numericSolvingSpeed = parseInt(solvingSpeed);\n    let skipPreviousEffect = false;\n\n    async function showSteps() {\n      if (numericSolvingSpeed === 0) {\n        setSudokuBoard(solvingSteps[solvingSteps.length - 1]);\n      } else {\n        for (let i = currentStepIdx.current; i < solvingSteps.length; i++) {\n          const step = solvingSteps[i];\n\n          if (!skipPreviousEffect) {\n            currentStepIdx.current = i;\n            setSudokuBoard(step);\n            await sleep(numericSolvingSpeed);\n          }\n        }\n      }\n    }\n\n    if (isSolvingSudoku) {\n      showSteps();\n    }\n\n    return () => {\n      skipPreviousEffect = true;\n    };\n  }, [solvingSpeed, solvingSteps, isSolvingSudoku]);\n\n  const setSudokuCell = (value: number, row: number, col: number) => {\n    const valuesCopy = deepCopy(sudokuBoard) as Board;\n\n    valuesCopy[row][col].value = value;\n    valuesCopy[row][col].isGiven = !!value;\n\n    setSudokuBoard(valuesCopy);\n  };\n\n  const handleSolvingSpeedChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setSolvingSpeed(e.target.value);\n  };\n\n  const handleClearClick = () => {\n    setIsSolvingSudoku(false);\n    setIsUnsolvable(false);\n    setSudokuBoard(generateEmptySudokuBoard());\n    currentStepIdx.current = 0;\n  };\n\n  const handleSolveClick = () => {\n    setIsSolvingSudoku(true);\n    const steps = solveSudokuSteps(deepCopy(sudokuBoard) as Board);\n    if (steps) {\n      setSolvingSteps(steps);\n    } else {\n      setIsUnsolvable(true);\n    }\n    currentStepIdx.current = 0;\n  };\n\n  const handleGenerateClick = () => {\n    setIsSolvingSudoku(false);\n    setIsUnsolvable(false);\n    setSudokuBoard(generateSolvableSudokuBoard());\n    currentStepIdx.current = 0;\n  };\n\n  return (\n    <Wrapper>\n      <UnsolvableNotice>{isUnsolvable && 'Unsolvable board'}</UnsolvableNotice>\n      <SudokuBoard\n        board={sudokuBoard}\n        setBoardCell={setSudokuCell}\n        disableUserInput={isSolvingSudoku}\n      />\n      <SolvingSpeedWrapper>\n        <SolvingSpeedLabel htmlFor=\"solving-speed-input\">Solving speed (ms):</SolvingSpeedLabel>\n        <SolvingSpeedInput\n          id=\"solving-speed-input\"\n          type=\"number\"\n          min=\"0\"\n          max=\"3000\"\n          value={solvingSpeed}\n          onChange={handleSolvingSpeedChange}\n        />\n      </SolvingSpeedWrapper>\n      <ButtonWrapper>\n        <Button type=\"button\" onClick={handleClearClick}>\n          Clear\n        </Button>\n        <Button type=\"button\" onClick={handleSolveClick} disabled={isSolvingSudoku}>\n          Solve\n        </Button>\n        <Button type=\"button\" onClick={handleGenerateClick}>\n          Generate\n        </Button>\n      </ButtonWrapper>\n    </Wrapper>\n  );\n}\n\nexport default SudokuSolver;\n","import React from 'react';\nimport styled from 'styled-components';\nimport SudokuSolver from './components/SudokuSolver';\n\nconst AppWrapper = styled.div`\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`;\n\nfunction App(): JSX.Element {\n  return (\n    <AppWrapper>\n      <SudokuSolver />\n    </AppWrapper>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}