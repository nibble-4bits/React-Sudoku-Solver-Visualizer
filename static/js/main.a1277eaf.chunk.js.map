{"version":3,"sources":["util/util.ts","util/sudoku.ts","components/SudokuCell.tsx","components/SudokuBoard.tsx","components/SudokuSolver.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["clamp","value","min","max","deepCopyArray","array","map","el","Array","isArray","sleep","ms","a","Promise","resolve","setTimeout","random","Error","Math","floor","shuffle","arr","arrCopy","i","length","j","temp","generateEmptySudokuBoard","from","isCellInBox","referenceRow","referenceCol","testRow","testCol","rowStart","rowEnd","colStart","colEnd","y","x","isValidValue","testValue","row","col","sudoku","isValidRowValue","isValidColValue","isValidBoxValue","findNextEmptyCell","solveSudoku","fillCellsSequentially","steps","push","emptyCell","possibleNums","possibleNum","Input","styled","input","props","highlight","SudokuCell","ref","onChange","onFocus","isHighlighted","disabled","onKeyDown","type","e","key","target","includes","preventDefault","test","onBlur","forwardRef","Wrapper","div","SudokuBoard","board","setBoardCell","disableUserInput","useState","focusedCell","setFocusedCell","focusedRow","focusedCol","cellRefs","useRef","createRef","handleKeyDown","aboveRow","belowRow","prevCol","nextCol","current","focus","boardRow","cellValue","inputVal","parseInt","handleChange","SolvingSpeedWrapper","SolvingSpeedLabel","label","SolvingSpeedInput","ButtonWrapper","Button","button","SudokuSolver","sudokuBoard","setSudokuBoard","solvingSteps","setSolvingSteps","solvingSpeed","setSolvingSpeed","isSolvingSudoku","setIsSolvingSudoku","currentStepIdx","useEffect","numericSolvingSpeed","skipPreviousEffect","step","showSteps","valuesCopy","htmlFor","id","onClick","solveSudokuSteps","initialSudoku","cellPositions","emptyCells","shuffledCellPositions","slice","generateSolvableSudokuBoard","AppWrapper","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oRAMO,SAASA,EAAMC,EAAeC,EAAaC,GAChD,OAAIF,EAAQC,EAAYA,EAEpBD,EAAQE,EAAYA,EAEjBF,EAOF,SAASG,EAAcC,GAC5B,OAAOA,EAAMC,KAAI,SAACC,GAChB,OAAIC,MAAMC,QAAQF,GACTH,EAAcG,GAEhBA,KAQJ,SAAeG,EAAtB,kC,4CAAO,WAAqBC,GAArB,SAAAC,EAAA,yDACM,IAAPD,EADC,0EAGE,IAAIE,SAAQ,SAACC,GAClBC,WAAWD,EAASH,OAJjB,4C,sBAaA,SAASK,EAAOd,EAAaC,GAClC,GAAID,EAAMC,EACR,MAAM,IAAIc,MAAM,0CAGlB,OAAOC,KAAKC,MAAMD,KAAKF,UAAYb,EAAMD,EAAM,IAAMA,EAOhD,SAASkB,EAAWC,GAGzB,IAFA,IAAMC,EAAUlB,EAAciB,GAErBE,EAAID,EAAQE,OAAS,EAAGD,EAAI,EAAGA,IAAK,CAC3C,IAAME,EAAIT,EAAO,EAAGO,GAEdG,EAAOJ,EAAQC,GACrBD,EAAQC,GAAKD,EAAQG,GACrBH,EAAQG,GAAKC,EAGf,OAAOJ,EChEF,SAASK,IACd,OAAOnB,MAAMoB,KAAK,CAAEJ,OAAQ,IAAK,kBAAMhB,MAAMoB,KAAK,CAAEJ,OAAQ,IAAK,kBAAM,QA+DlE,SAASK,EACdC,EACAC,EACAC,EACAC,GAEA,GAAIH,EAAe,GAAKC,EAAe,EAAG,OAAO,EAOjD,IALA,IAAMG,EAAWJ,EAAgBA,EAAe,EAC1CK,EAASD,EAAW,EACpBE,EAAWL,EAAgBA,EAAe,EAC1CM,EAASD,EAAW,EAEjBE,EAAIJ,EAAUI,EAAIH,EAAQG,IACjC,IAAK,IAAIC,EAAIH,EAAUG,EAAIF,EAAQE,IACjC,GAAID,IAAMN,GAAWO,IAAMN,EACzB,OAAO,EAKb,OAAO,EAGF,SAASO,EACdC,EACAC,EACAC,EACAC,GAEA,OAOK,SAAyBH,EAAmBC,EAAaE,GAC9D,IAAK,IAAIL,EAAI,EAAGA,EAAIK,EAAOF,GAAKlB,OAAQe,IAAK,CAE3C,GAAIE,IADcG,EAAOF,GAAKH,GAE5B,OAAO,EAIX,OAAO,EAdLM,CAAgBJ,EAAWC,EAAKE,IAiB7B,SAAyBH,EAAmBE,EAAaC,GAC9D,IAAK,IAAIN,EAAI,EAAGA,EAAIM,EAAOpB,OAAQc,IAAK,CAEtC,GAAIG,IADcG,EAAON,GAAGK,GAE1B,OAAO,EAIX,OAAO,EAxBLG,CAAgBL,EAAWE,EAAKC,IA2B7B,SACLH,EACAC,EACAC,EACAC,GAOA,IALA,IAAMV,EAAWQ,EAAOA,EAAM,EACxBP,EAASD,EAAW,EACpBE,EAAWO,EAAOA,EAAM,EACxBN,EAASD,EAAW,EAEjBE,EAAIJ,EAAUI,EAAIH,EAAQG,IACjC,IAAK,IAAIC,EAAIH,EAAUG,EAAIF,EAAQE,IAAK,CAEtC,GAAIE,IADcG,EAAON,GAAGC,GAE1B,OAAO,EAKb,OAAO,EA9CLQ,CAAgBN,EAAWC,EAAKC,EAAKC,GAiDlC,SAASI,EAAkBJ,GAChC,IAAK,IAAIrB,EAAI,EAAGA,EAAIqB,EAAOpB,OAAQD,IACjC,IAAK,IAAIE,EAAI,EAAGA,EAAImB,EAAOrB,GAAGC,OAAQC,IACpC,IAAKmB,EAAOrB,GAAGE,GACb,MAAO,CAACF,EAAGE,GAKjB,OAAO,KAGF,SAASwB,EACdL,GAGU,IAFVM,IAES,yDADTC,EACS,uCACLA,GAAOA,EAAMC,KAAKhD,EAAcwC,IAEpC,IAAMS,EAAYL,EAAkBJ,GACpC,IAAKS,EACH,OAAO,EALA,kBAQUA,EARV,GAQFX,EARE,KAQGC,EARH,KASLW,EAAe,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACvCJ,IACHI,EAAelC,EAAQkC,IAXhB,oBAciBA,GAdjB,IAcT,2BAAwC,CAAC,IAA9BC,EAA6B,QACtC,GAAIf,EAAae,EAAab,EAAKC,EAAKC,GAAS,CAG/C,GAFAA,EAAOF,GAAKC,GAAOY,EAEfN,EAAYL,EAAQM,EAAuBC,GAC7C,OAAO,EAGTP,EAAOF,GAAKC,GAAO,IAtBd,8BA0BT,OAAO,E,aCtLHa,EAAQC,IAAOC,MAAV,2eAIM,SAACC,GAAD,OAAWA,EAAMhB,IAAM,GAAKgB,EAAMhB,IAAM,IAAM,GAAK,oBACpD,SAACgB,GAAD,OAAWA,EAAMjB,IAAM,GAAKiB,EAAMjB,IAAM,IAAM,GAAK,oBAC7C,SAACiB,GAAD,OAAWA,EAAMC,WAAa,UA+BpD,SAASC,EAAWF,EAAwBG,GAA4C,IAC9EpB,EAA2EiB,EAA3EjB,IAAKC,EAAsEgB,EAAtEhB,IAAK1C,EAAiE0D,EAAjE1D,MAAO8D,EAA0DJ,EAA1DI,SAAUC,EAAgDL,EAAhDK,QAASC,EAAuCN,EAAvCM,cAAeC,EAAwBP,EAAxBO,SAAUC,EAAcR,EAAdQ,UAkCrE,OACE,cAACX,EAAD,CACEM,IAAKA,EACLM,KAAK,SACLlE,IAAI,IACJC,IAAI,IACJgE,UAtCkB,SAACE,GAEjBF,GACFA,EAAUE,GAHsD,IAOhEC,EAIED,EAJFC,IAGUrE,EACRoE,EADFE,OAAUtE,MAIR,CAAC,UAAW,aAAauE,SAASF,IACpCD,EAAEI,iBAIAxE,GAAS,KAAKyE,KAAKJ,IACrBD,EAAEI,kBAmBFV,SAAUA,EACVC,QAhBgB,WAClBA,EAAQ,CAACtB,EAAKC,KAgBZgC,OAbe,WACjBX,EAAQ,EAAE,GAAI,KAaZ/D,MAAOA,GAAS,GAChByC,IAAKA,EACLC,IAAKA,EACLuB,SAAUA,EACVN,UAAWK,IAKFW,I,EAAAA,uBAAWf,GCxFpBgB,EAAUpB,IAAOqB,IAAV,kNA0FEC,I,YAAAA,EA1Ef,SAAqBpB,GAAuC,IAClDqB,EAA0CrB,EAA1CqB,MAAOC,EAAmCtB,EAAnCsB,aAAcC,EAAqBvB,EAArBuB,iBAD4B,EAInBC,mBAAS,EAAE,GAAI,IAJI,mBAIlDC,EAJkD,KAIrCC,EAJqC,mBAKxBD,EALwB,GAKlDE,EALkD,KAKtCC,EALsC,KASnDC,EAAWC,iBFLVjF,MAAMoB,KAAK,CAAEJ,OAAQ,IAAK,kBAAMhB,MAAMoB,KAAK,CAAEJ,OAAQ,IAAK,kBAAMkE,6BEejEC,EAAgB,SAACtB,GAA8C,IAAD,QAC1DC,EAAQD,EAARC,IACFsB,EAAW5F,EAAMsF,EAAa,EAAG,EAAGN,EAAMxD,OAAS,GACnDqE,EAAW7F,EAAMsF,EAAa,EAAG,EAAGN,EAAMxD,OAAS,GACnDsE,EAAU9F,EAAMuF,EAAa,EAAG,EAAGP,EAAMxD,OAAS,GAClDuE,EAAU/F,EAAMuF,EAAa,EAAG,EAAGP,EAAMxD,OAAS,GAExD,OAAQ8C,GACN,IAAK,UACH,UAAAkB,EAASQ,QAAQJ,GAAUL,GAAYS,eAAvC,SAAgDC,QAChD,MACF,IAAK,YACH,UAAAT,EAASQ,QAAQH,GAAUN,GAAYS,eAAvC,SAAgDC,QAChD,MACF,IAAK,YACH,UAAAT,EAASQ,QAAQV,GAAYQ,GAASE,eAAtC,SAA+CC,QAC/C,MACF,IAAK,aACH,UAAAT,EAASQ,QAAQV,GAAYS,GAASC,eAAtC,SAA+CC,UAOrD,OACE,cAACpB,EAAD,UACGG,EAAM1E,KAAI,SAAC4F,EAAU3E,GACpB,OAAO2E,EAAS5F,KAAI,SAAC6F,EAAW1E,GAC9B,OACE,cAAC,EAAD,CACEqC,IAAK0B,EAASQ,QAAQzE,GAAGE,GAEzBiB,IAAKnB,EACLoB,IAAKlB,EACLxB,MAAOkG,EACPpC,SAAU,SAACM,IA5CF,SAACA,EAAwC3B,EAAaC,GACzE,IAAMyD,EAAWC,SAAShC,EAAEE,OAAOtE,OAE/BuC,EAAa4D,EAAU1D,EAAKC,EAAKqC,IACnCC,EAAamB,EAAU1D,EAAKC,GAyClB2D,CAAajC,EAAG9C,EAAGE,IAErBuC,QAASqB,EACTpB,eF9CcnC,EE+CAwD,EF/CsBtD,EE+CVT,IF9ClCO,EAAe,IAEZA,IAAiBE,IASED,EEoCAwD,EFpCsBtD,EEoCVR,IFnClCM,EAAe,IAEZA,IAAiBE,IEkCVJ,EAAYyD,EAAYC,EAAYhE,EAAGE,IAEzCyC,SAAUgB,EACVf,UAAWwB,GAdNpE,EAAIE,GF1BhB,IAAqBM,EAAsBE,EAZtBH,EAAsBE,WG/B5C6C,EAAUpB,IAAOqB,IAAV,mGAMPyB,EAAsB9C,IAAOqB,IAAV,gHAOnB0B,EAAoB/C,IAAOgD,MAAV,gDAIjBC,EAAoBjD,IAAOC,MAAV,wGAOjBiD,EAAgBlD,IAAOqB,IAAV,wFAMb8B,EAASnD,IAAOoD,OAAV,kTA2HGC,I,EAAAA,EAxGf,WAAqC,MAEG3B,mBAASxD,KAFZ,mBAE5BoF,EAF4B,KAEfC,EAFe,OAGK7B,mBAAuB,IAH5B,mBAG5B8B,EAH4B,KAGdC,EAHc,OAKK/B,mBAAS,KALd,mBAK5BgC,EAL4B,KAKdC,EALc,OAMWjC,oBAAS,GANpB,mBAM5BkC,EAN4B,KAMXC,EANW,KAO7BC,EAAiB9B,iBAAO,GAgE9B,OA9DA+B,qBAAU,WACR,IAAMC,EAAsBpB,SAASc,GACjCO,GAAqB,EAFX,4CAId,8BAAA9G,EAAA,yDAC8B,IAAxB6G,EADN,gBAEIT,EAAeC,EAAaA,EAAazF,OAAS,IAFtD,uBAIaD,EAAIgG,EAAevB,QAJhC,YAIyCzE,EAAI0F,EAAazF,QAJ1D,oBAKYmG,EAAOV,EAAa1F,GAErBmG,EAPX,wBAQQH,EAAevB,QAAUzE,EACzByF,EAAeW,GATvB,UAUcjH,EAAM+G,GAVpB,QAIkElG,IAJlE,4DAJc,sBAwBd,OAJI8F,GApBU,mCAqBZO,GAGK,WACLF,GAAqB,KAEtB,CAACP,EAAcF,EAAcI,IAoC9B,eAAC,EAAD,WACE,cAAC,EAAD,CACErC,MAAO+B,EACP9B,aArCgB,SAAChF,EAAeyC,EAAaC,GACjD,IAAMkF,EAAazH,EAAc2G,GAEjCc,EAAWnF,GAAKC,GAAO1C,EAEvB+G,EAAea,IAiCX3C,iBAAkBmC,IAEpB,eAACd,EAAD,WACE,cAACC,EAAD,CAAmBsB,QAAQ,sBAA3B,iCACA,cAACpB,EAAD,CACEqB,GAAG,sBACH3D,KAAK,SACLlE,IAAI,IACJC,IAAI,OACJF,MAAOkH,EACPpD,SAxCyB,SAACM,GAChC+C,EAAgB/C,EAAEE,OAAOtE,aA0CvB,eAAC0G,EAAD,WACE,cAACC,EAAD,CAAQxC,KAAK,SAAS4D,QAxCH,WACvBV,GAAmB,GACnBN,EAAerF,KACf4F,EAAevB,QAAU,GAqCrB,mBAGA,cAACY,EAAD,CAAQxC,KAAK,SAAS4D,QArCH,WACvBV,GAAmB,GACnB,IAAMnE,EH6EH,SAA0BP,GAC/B,IAAMO,EAAsB,GAI5B,OAFeF,EAAYL,GAAQ,EAAMO,GAEtBA,EACZ,KGnFS8E,CAAiB7H,EAAc2G,IACzC5D,GACF+D,EAAgB/D,GAElBoE,EAAevB,QAAU,GA+B4B9B,SAAUmD,EAA3D,mBAGA,cAACT,EAAD,CAAQxC,KAAK,SAAS4D,QA/BA,WAC1BV,GAAmB,GACnBN,EHvHG,WACL,IAAMkB,EAAgB1H,MAAMoB,KAAK,CAAEJ,OAAQ,IAAK,kBAAMhB,MAAMoB,KAAK,CAAEJ,OAAQ,IAAK,kBAAM,QAChF2G,EAAgB,GAEtBlF,EAAYiF,GAAe,GAE3B,IAAK,IAAI3G,EAAI,EAAGA,EAAI2G,EAAc1G,OAAQD,IACxC,IAAK,IAAIE,EAAI,EAAGA,EAAIyG,EAAc3G,GAAGC,OAAQC,IAC3C0G,EAAc/E,KAAK,CAAC7B,EAAGE,IAQ3B,IAHA,IAAM2G,EAAapH,EAAO,GAAI,IACxBqH,EAAwBjH,EAAQ+G,GAAeG,MAAM,EAAGF,GAErD7G,EAAI,EAAGA,EAAI8G,EAAsB7G,OAAQD,IAAK,CAAC,IAAD,cAClC8G,EAAsB9G,GADY,GAC9CmB,EAD8C,KACzCC,EADyC,KAErDuF,EAAcxF,GAAKC,GAAO,EAG5B,OAAOuF,EGkGUK,IACfhB,EAAevB,QAAU,GA4BrB,6BCvJFwC,EAAa/E,IAAOqB,IAAV,oHAeD2D,MARf,WACE,OACE,cAACD,EAAD,UACE,cAAC,EAAD,OCASE,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.a1277eaf.chunk.js","sourcesContent":["/**\n * Clamps a value between an upper and lower bound\n * @param value The value to be clamped, if necessary\n * @param min The minimum allowed value\n * @param max The maximum allowed value\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (value < min) return min;\n\n  if (value > max) return max;\n\n  return value;\n}\n\n/**\n * Returns the deep copy of an array\n * @param array The array to be deep copied\n */\nexport function deepCopyArray(array: unknown[]): unknown {\n  return array.map((el) => {\n    if (Array.isArray(el)) {\n      return deepCopyArray(el);\n    }\n    return el;\n  });\n}\n\n/**\n * Pauses execution for a certain number of milliseconds\n * @param ms Number of milliseconds to pause\n */\nexport async function sleep(ms: number): Promise<void> {\n  if (ms === 0) return;\n\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\n/**\n * Returns a random integer between a `min` and `max` value (inclusive)\n * @param min The minimum value in the range\n * @param max The maximum value in the range\n */\nexport function random(min: number, max: number): number {\n  if (min > max) {\n    throw new Error('min param MUST be less or equal to max');\n  }\n\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Shuffles an array using the Fisher-Yates algorithm\n * @param arr The array to be shuffled\n */\nexport function shuffle<T>(arr: T[]): T[] {\n  const arrCopy = deepCopyArray(arr) as T[];\n\n  for (let i = arrCopy.length - 1; i > 0; i--) {\n    const j = random(0, i);\n\n    const temp = arrCopy[i];\n    arrCopy[i] = arrCopy[j];\n    arrCopy[j] = temp;\n  }\n\n  return arrCopy;\n}\n","import { createRef } from 'react';\nimport { deepCopyArray, random, shuffle } from './util';\n\nexport function generateEmptySudokuBoard(): number[][] {\n  return Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => 0));\n}\n\nexport function generateSolvableSudokuBoard(): number[][] {\n  const initialSudoku = Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => 0));\n  const cellPositions = [];\n\n  solveSudoku(initialSudoku, false);\n\n  for (let i = 0; i < initialSudoku.length; i++) {\n    for (let j = 0; j < initialSudoku[i].length; j++) {\n      cellPositions.push([i, j]);\n    }\n  }\n\n  // Randomly remove between 48 and 62 cells from the generated sudoku\n  const emptyCells = random(48, 62);\n  const shuffledCellPositions = shuffle(cellPositions).slice(0, emptyCells);\n\n  for (let i = 0; i < shuffledCellPositions.length; i++) {\n    const [row, col] = shuffledCellPositions[i];\n    initialSudoku[row][col] = 0;\n  }\n\n  return initialSudoku;\n}\n\nexport function generateSudokuCellRefs<T>(): React.RefObject<T>[][] {\n  return Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => createRef()));\n}\n\n/**\n * Checks whether a cell (given its row) is part of a certain row in the sudoku board\n * @param referenceRow The row to test against\n * @param testRow The row of the cell to test if it belongs to the `referenceRow`\n * @returns boolean\n */\nexport function isCellInRow(referenceRow: number, testRow: number): boolean {\n  if (referenceRow < 0) return false;\n\n  return referenceRow === testRow;\n}\n\n/**\n * Checks whether a cell (given its column) is part of a certain column in the sudoku board\n * @param referenceCol The column to test against\n * @param testCol The column of the cell to test if it belongs to the `referenceRow`\n * @returns boolean\n */\nexport function isCellInCol(referenceCol: number, testCol: number): boolean {\n  if (referenceCol < 0) return false;\n\n  return referenceCol === testCol;\n}\n\n/**\n * Checks whether a cell (given its row and column) is part of a certain box in the sudoku board\n * @param referenceRow The row to test against\n * @param referenceCol The column to test against\n * @param testRow The row of the cell to test if it belongs to the `referenceRow`\n * @param testCol The column of the cell to test if it belongs to the `referenceCol`\n * @returns boolean\n */\nexport function isCellInBox(\n  referenceRow: number,\n  referenceCol: number,\n  testRow: number,\n  testCol: number\n): boolean {\n  if (referenceRow < 0 || referenceCol < 0) return false;\n\n  const rowStart = referenceRow - (referenceRow % 3);\n  const rowEnd = rowStart + 3;\n  const colStart = referenceCol - (referenceCol % 3);\n  const colEnd = colStart + 3;\n\n  for (let y = rowStart; y < rowEnd; y++) {\n    for (let x = colStart; x < colEnd; x++) {\n      if (y === testRow && x === testCol) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function isValidValue(\n  testValue: number,\n  row: number,\n  col: number,\n  sudoku: number[][]\n): boolean {\n  return (\n    isValidRowValue(testValue, row, sudoku) &&\n    isValidColValue(testValue, col, sudoku) &&\n    isValidBoxValue(testValue, row, col, sudoku)\n  );\n}\n\nexport function isValidRowValue(testValue: number, row: number, sudoku: number[][]): boolean {\n  for (let x = 0; x < sudoku[row].length; x++) {\n    const currValue = sudoku[row][x];\n    if (testValue === currValue) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isValidColValue(testValue: number, col: number, sudoku: number[][]): boolean {\n  for (let y = 0; y < sudoku.length; y++) {\n    const currValue = sudoku[y][col];\n    if (testValue === currValue) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isValidBoxValue(\n  testValue: number,\n  row: number,\n  col: number,\n  sudoku: number[][]\n): boolean {\n  const rowStart = row - (row % 3);\n  const rowEnd = rowStart + 3;\n  const colStart = col - (col % 3);\n  const colEnd = colStart + 3;\n\n  for (let y = rowStart; y < rowEnd; y++) {\n    for (let x = colStart; x < colEnd; x++) {\n      const currValue = sudoku[y][x];\n      if (testValue === currValue) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function findNextEmptyCell(sudoku: number[][]): [number, number] | null {\n  for (let i = 0; i < sudoku.length; i++) {\n    for (let j = 0; j < sudoku[i].length; j++) {\n      if (!sudoku[i][j]) {\n        return [i, j];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function solveSudoku(\n  sudoku: number[][],\n  fillCellsSequentially = true,\n  steps?: number[][][]\n): boolean {\n  if (steps) steps.push(deepCopyArray(sudoku) as number[][]);\n\n  const emptyCell = findNextEmptyCell(sudoku);\n  if (!emptyCell) {\n    return true;\n  }\n\n  const [row, col] = emptyCell;\n  let possibleNums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n  if (!fillCellsSequentially) {\n    possibleNums = shuffle(possibleNums);\n  }\n\n  for (const possibleNum of possibleNums) {\n    if (isValidValue(possibleNum, row, col, sudoku)) {\n      sudoku[row][col] = possibleNum;\n\n      if (solveSudoku(sudoku, fillCellsSequentially, steps)) {\n        return true;\n      }\n\n      sudoku[row][col] = 0;\n    }\n  }\n\n  return false;\n}\n\nexport function solveSudokuSteps(sudoku: number[][]): number[][][] | null {\n  const steps: number[][][] = [];\n\n  const solved = solveSudoku(sudoku, true, steps);\n\n  if (solved) return steps;\n  return null;\n}\n","import React, { forwardRef } from 'react';\nimport styled from 'styled-components';\n\ninterface InputProps {\n  row: number;\n  col: number;\n  highlight: boolean;\n}\n\nconst Input = styled.input<InputProps>`\n  width: 100%;\n  height: 100%;\n  border: 1px solid #000;\n  border-left: ${(props) => props.col > 0 && props.col % 3 === 0 && '3px solid #000'};\n  border-top: ${(props) => props.row > 0 && props.row % 3 === 0 && '3px solid #000'};\n  background-color: ${(props) => props.highlight && '#ddd'};\n  outline: none;\n  font-size: 4rem;\n  text-align: center;\n  padding: 0;\n\n  &:disabled {\n    background-color: #fff;\n    color: #000;\n  }\n\n  // Hide increment/decrement arrows\n  -moz-appearance: textfield;\n  &::-webkit-outer-spin-button,\n  &::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n`;\n\ninterface SudokuCellProps {\n  row: number;\n  col: number;\n  value: number;\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n  onFocus: React.Dispatch<React.SetStateAction<number[]>>;\n  isHighlighted: boolean;\n  disabled?: boolean;\n  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n}\n\nfunction SudokuCell(props: SudokuCellProps, ref: React.ForwardedRef<HTMLInputElement>) {\n  const { row, col, value, onChange, onFocus, isHighlighted, disabled, onKeyDown } = props;\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    // First, call props onKeyDown event handler, if defined\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n\n    const {\n      key,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      target: { value },\n    } = e;\n\n    // Prevent up and down arrow keys from incrementing/decrementing focused cell value\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      e.preventDefault();\n    }\n\n    // Prevent entering more than 1 digit, if cell already has a value and the pressed key is a number key\n    if (value && /\\d/.test(key)) {\n      e.preventDefault();\n    }\n  };\n\n  const handleFocus = () => {\n    onFocus([row, col]);\n  };\n\n  const handleBlur = () => {\n    onFocus([-1, -1]);\n  };\n\n  return (\n    <Input\n      ref={ref}\n      type=\"number\"\n      min=\"1\"\n      max=\"9\"\n      onKeyDown={handleKeyDown}\n      onChange={onChange}\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      value={value || ''}\n      row={row}\n      col={col}\n      disabled={disabled}\n      highlight={isHighlighted}\n    />\n  );\n}\n\nexport default forwardRef(SudokuCell);\n","import React, { useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport {\n  generateSudokuCellRefs,\n  isCellInBox,\n  isCellInCol,\n  isCellInRow,\n  isValidValue,\n} from '../util/sudoku';\nimport { clamp } from '../util/util';\nimport SudokuCell from './SudokuCell';\n\nconst Wrapper = styled.div`\n  width: 600px;\n  height: 600px;\n  display: grid;\n  grid-template-rows: repeat(9, 1fr);\n  grid-template-columns: repeat(9, 1fr);\n  border: 5px solid #000;\n  overflow: hidden;\n`;\n\ninterface SudokuBoardProps {\n  board: number[][];\n  setBoardCell: (value: number, row: number, col: number) => void;\n  disableUserInput?: boolean;\n}\n\nfunction SudokuBoard(props: SudokuBoardProps): JSX.Element {\n  const { board, setBoardCell, disableUserInput } = props;\n\n  // This state variable holds a pair of [row, col] coordinates that represent the current focused cell\n  const [focusedCell, setFocusedCell] = useState([-1, -1]);\n  const [focusedRow, focusedCol] = focusedCell;\n\n  // An array of array of refs. Each ref holds a reference to the actual input element that represents a cell\n  // This is used to focus the current focused cell when using the arrow keys in the `handleKeyDown` event handler\n  const cellRefs = useRef<React.RefObject<HTMLInputElement>[][]>(generateSudokuCellRefs());\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>, row: number, col: number) => {\n    const inputVal = parseInt(e.target.value);\n\n    if (isValidValue(inputVal, row, col, board)) {\n      setBoardCell(inputVal, row, col);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const { key } = e;\n    const aboveRow = clamp(focusedRow - 1, 0, board.length - 1);\n    const belowRow = clamp(focusedRow + 1, 0, board.length - 1);\n    const prevCol = clamp(focusedCol - 1, 0, board.length - 1);\n    const nextCol = clamp(focusedCol + 1, 0, board.length - 1);\n\n    switch (key) {\n      case 'ArrowUp':\n        cellRefs.current[aboveRow][focusedCol].current?.focus();\n        break;\n      case 'ArrowDown':\n        cellRefs.current[belowRow][focusedCol].current?.focus();\n        break;\n      case 'ArrowLeft':\n        cellRefs.current[focusedRow][prevCol].current?.focus();\n        break;\n      case 'ArrowRight':\n        cellRefs.current[focusedRow][nextCol].current?.focus();\n        break;\n      default:\n        break;\n    }\n  };\n\n  return (\n    <Wrapper>\n      {board.map((boardRow, i) => {\n        return boardRow.map((cellValue, j) => {\n          return (\n            <SudokuCell\n              ref={cellRefs.current[i][j]}\n              key={i + j}\n              row={i}\n              col={j}\n              value={cellValue}\n              onChange={(e) => {\n                handleChange(e, i, j);\n              }}\n              onFocus={setFocusedCell}\n              isHighlighted={\n                isCellInRow(focusedRow, i) ||\n                isCellInCol(focusedCol, j) ||\n                isCellInBox(focusedRow, focusedCol, i, j)\n              }\n              disabled={disableUserInput}\n              onKeyDown={handleKeyDown}\n            />\n          );\n        });\n      })}\n    </Wrapper>\n  );\n}\n\nexport default SudokuBoard;\n","import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport {\n  generateEmptySudokuBoard,\n  generateSolvableSudokuBoard,\n  solveSudokuSteps,\n} from '../util/sudoku';\nimport { deepCopyArray, sleep } from '../util/util';\nimport SudokuBoard from './SudokuBoard';\n\nconst Wrapper = styled.div`\n  display: grid;\n  grid-template-rows: 10fr 4rem 4rem;\n  gap: 2rem;\n`;\n\nconst SolvingSpeedWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  gap: 1rem;\n`;\n\nconst SolvingSpeedLabel = styled.label`\n  font-size: 2rem;\n`;\n\nconst SolvingSpeedInput = styled.input`\n  width: 10rem;\n  height: 75%;\n  text-align: center;\n  font-size: 2rem;\n`;\n\nconst ButtonWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  gap: 5rem;\n`;\n\nconst Button = styled.button`\n  color: #fff;\n  background-color: #267ef1;\n  font-size: 1.8rem;\n  width: 20%;\n  border: none;\n  border-radius: 5px;\n\n  &:hover {\n    background-color: #256cca;\n    cursor: pointer;\n  }\n\n  &:disabled {\n    background-color: #478fec;\n    cursor: not-allowed;\n  }\n`;\n\nfunction SudokuSolver(): JSX.Element {\n  // This state variable holds a representation of the sudoku board as an array of 9x9 cells\n  const [sudokuBoard, setSudokuBoard] = useState(generateEmptySudokuBoard());\n  const [solvingSteps, setSolvingSteps] = useState<number[][][]>([]);\n\n  const [solvingSpeed, setSolvingSpeed] = useState('1');\n  const [isSolvingSudoku, setIsSolvingSudoku] = useState(false);\n  const currentStepIdx = useRef(0);\n\n  useEffect(() => {\n    const numericSolvingSpeed = parseInt(solvingSpeed);\n    let skipPreviousEffect = false;\n\n    async function showSteps() {\n      if (numericSolvingSpeed === 0) {\n        setSudokuBoard(solvingSteps[solvingSteps.length - 1]);\n      } else {\n        for (let i = currentStepIdx.current; i < solvingSteps.length; i++) {\n          const step = solvingSteps[i];\n\n          if (!skipPreviousEffect) {\n            currentStepIdx.current = i;\n            setSudokuBoard(step);\n            await sleep(numericSolvingSpeed);\n          }\n        }\n      }\n    }\n\n    if (isSolvingSudoku) {\n      showSteps();\n    }\n\n    return () => {\n      skipPreviousEffect = true;\n    };\n  }, [solvingSpeed, solvingSteps, isSolvingSudoku]);\n\n  const setSudokuCell = (value: number, row: number, col: number) => {\n    const valuesCopy = deepCopyArray(sudokuBoard) as number[][];\n\n    valuesCopy[row][col] = value;\n\n    setSudokuBoard(valuesCopy);\n  };\n\n  const handleSolvingSpeedChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setSolvingSpeed(e.target.value);\n  };\n\n  const handleClearClick = () => {\n    setIsSolvingSudoku(false);\n    setSudokuBoard(generateEmptySudokuBoard());\n    currentStepIdx.current = 0;\n  };\n\n  const handleSolveClick = () => {\n    setIsSolvingSudoku(true);\n    const steps = solveSudokuSteps(deepCopyArray(sudokuBoard) as number[][]);\n    if (steps) {\n      setSolvingSteps(steps);\n    }\n    currentStepIdx.current = 0;\n  };\n\n  const handleGenerateClick = () => {\n    setIsSolvingSudoku(false);\n    setSudokuBoard(generateSolvableSudokuBoard());\n    currentStepIdx.current = 0;\n  };\n\n  return (\n    <Wrapper>\n      <SudokuBoard\n        board={sudokuBoard}\n        setBoardCell={setSudokuCell}\n        disableUserInput={isSolvingSudoku}\n      />\n      <SolvingSpeedWrapper>\n        <SolvingSpeedLabel htmlFor=\"solving-speed-input\">Solving speed (ms):</SolvingSpeedLabel>\n        <SolvingSpeedInput\n          id=\"solving-speed-input\"\n          type=\"number\"\n          min=\"0\"\n          max=\"3000\"\n          value={solvingSpeed}\n          onChange={handleSolvingSpeedChange}\n        />\n      </SolvingSpeedWrapper>\n      <ButtonWrapper>\n        <Button type=\"button\" onClick={handleClearClick}>\n          Clear\n        </Button>\n        <Button type=\"button\" onClick={handleSolveClick} disabled={isSolvingSudoku}>\n          Solve\n        </Button>\n        <Button type=\"button\" onClick={handleGenerateClick}>\n          Generate\n        </Button>\n      </ButtonWrapper>\n    </Wrapper>\n  );\n}\n\nexport default SudokuSolver;\n","import React from 'react';\nimport styled from 'styled-components';\nimport SudokuSolver from './components/SudokuSolver';\n\nconst AppWrapper = styled.div`\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`;\n\nfunction App(): JSX.Element {\n  return (\n    <AppWrapper>\n      <SudokuSolver />\n    </AppWrapper>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}